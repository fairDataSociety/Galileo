import {createAsyncThunk, createSlice} from '@reduxjs/toolkit';
import FairOS from "../../service/FairOS";
import {setActiveItem} from "../catalog/catalogSlice";
import {clearOsmIndex, getOsmIndex, saveOsmIndex, setWindowIndex} from "../../service/LocalData";
import {REGISTRY_KV_NAME} from "../../service/SharedData";

const initialState = {
    status: 'idle',
    statusText: '',
    isLoggedIn: false,
    username: '',
    password: '',
    pod: '',
    kv: '',
    registry: {}
};

async function importDefaultRegistry(dispatch, fairOS, password) {
    const reference = process.env.REACT_APP_DEFAULT_REGISTRY_REFERENCE;
    if (reference) {
        const registryInfo = await fairOS.podReceiveInfo(reference);
        const podName = registryInfo?.pod_name;
        if (!podName) {
            console.error(`Registry info not found: ${reference}`);
            return;
        }

        await fairOS.podReceive(reference);
        await fairOS.podOpen(podName, password);
        await fairOS.kvOpen(podName, REGISTRY_KV_NAME);
        dispatch(setRegistry({
            reference,
            pod_name: registryInfo.pod_name
        }));

    } else {
        console.error('REACT_APP_DEFAULT_REGISTRY_REFERENCE is not defined');
    }
}

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const login = createAsyncThunk(
    'user/login',
    async ({username, password}, {dispatch, getState}) => {
        const fairOS = new FairOS();
        const data = await fairOS.login(username, password);
        await importDefaultRegistry(dispatch, fairOS, password);
        localStorage.setItem('osm_username', username);
        localStorage.setItem('osm_password', password);
        const isLoggedIn = data.code === 200;
        if (isLoggedIn) {
            const index = await fairOS.getMapsIndex(password);
            saveOsmIndex(index);
        } else {
            clearOsmIndex();
        }

        dispatch(setUser({username, password, isLoggedIn}));

        return isLoggedIn;
    }
);

export const tryLogin = createAsyncThunk(
    'user/tryLogin',
    async (params, {dispatch, getState}) => {
        const fairOS = new FairOS();
        const username = localStorage.getItem('osm_username');
        const password = localStorage.getItem('osm_password');
        // let activeMap = localStorage.getItem('osm_active');
        if (!username || !password) {
            return false;
        }

        const data = await fairOS.login(username, password);
        await importDefaultRegistry(dispatch, fairOS, password);
        const isLoggedIn = data.code === 200;
        if (isLoggedIn) {
            await fairOS.openAll(password);
        }

        setWindowIndex(getOsmIndex());

        dispatch(setUser({username, password, isLoggedIn}));

        return isLoggedIn;
    }
);

export const userSlice = createSlice({
    name: 'user',
    initialState,
    // The `reducers` field lets us define reducers and generate associated actions
    reducers: {
        setUser: (state, action) => {
            const {isLoggedIn, username, password, pod, kv} = action.payload;
            state.isLoggedIn = !!isLoggedIn;
            state.username = username;
            state.password = password;
            state.pod = pod ? pod : null;
            state.kv = kv ? kv : null;
        },
        fullReset: (state) => {
            state.isLoggedIn = false;
            state.username = '';
            state.password = '';
            state.pod = '';
            state.kv = '';
        },
        resetStatus: (state) => {
            state.status = '';
            state.statusText = '';
        },
        setRegistry: (state, action) => {
            state.registry = action.payload;
        }
    },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    extraReducers: (builder) => {
        builder
            .addCase(login.fulfilled, (state, action) => {
                state.status = 'idle';
            })
            .addCase(login.pending, (state) => {
                state.status = 'login';
            })
            .addCase(login.rejected, (state, action) => {
                state.status = 'error';
                state.statusText = action.error.message;
            })

            .addCase(tryLogin.fulfilled, (state, action) => {
                state.status = 'idle';
            })
            .addCase(tryLogin.pending, (state) => {
                state.status = 'login';
            })
            .addCase(tryLogin.rejected, (state, action) => {
                state.status = 'error';
            });
    },
});

export const {setUser, resetStatus, fullReset, setRegistry} = userSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
// export const selectCount = (state) => state.user.value;
export const selectUser = (state) => state.user;

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.
export const logout = () => (dispatch) => {
    dispatch(fullReset());
    dispatch(setActiveItem(null));
    localStorage.clear();
};

export default userSlice.reducer;
